/* eslint-disable no-restricted-globals, no-undef */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';

// Track app version for update detection
let currentVersion = '0.0.0';
let previousVersion = null;

// The app version is injected during service worker registration
// This ensures we only need to update the version in one place: src/config/appConfig.js
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'APP_VERSION') {
    // Store previous version before updating
    if (self.APP_VERSION) {
      previousVersion = self.APP_VERSION;
    }
    
    // Update to new version
    self.APP_VERSION = event.data.version;
    currentVersion = event.data.version;
    
    console.log('Service Worker received app version:', self.APP_VERSION);
    
    // If this is an update (not first install), trigger cleanup
    if (previousVersion && previousVersion !== currentVersion) {
      console.log(`App updated from ${previousVersion} to ${currentVersion}, cleaning up old data...`);
      cleanupOnUpdate();
    }
  }
  
  // Handle explicit cleanup request from the app
  if (event.data && event.data.type === 'CLEAN_CACHES') {
    console.log('Received request to clean caches');
    cleanupOnUpdate();
  }
});

// Function to clean up caches and IndexedDB data while preserving login and theme
async function cleanupOnUpdate() {
  try {
    // 1. Preserve essential data
    const essentialData = {};
    
    // Save authentication data (from localStorage)
    const authUser = localStorage.getItem('user');
    if (authUser) {
      essentialData.user = authUser;
    }
    
    // Save theme preference
    const themeMode = localStorage.getItem('themeMode');
    if (themeMode) {
      essentialData.themeMode = themeMode;
    }
    
    // 2. Clean all caches except the precache
    const cacheKeys = await caches.keys();
    const cachesToDelete = cacheKeys.filter(key => 
      !key.includes('precache') && !key.includes('workbox-precache')
    );
    
    await Promise.all(
      cachesToDelete.map(async (cacheKey) => {
        console.log(`Deleting cache: ${cacheKey}`);
        await caches.delete(cacheKey);
      })
    );
    
    // 3. Clean localStorage except for essential items
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      // Skip essential items we want to preserve
      if (key !== 'user' && key !== 'themeMode') {
        localStorage.removeItem(key);
      }
    }
    
    // 4. Clear sessionStorage completely (temporary data)
    sessionStorage.clear();
    
    // 5. Restore the saved essential data
    if (essentialData.user) {
      localStorage.setItem('user', essentialData.user);
    }
    if (essentialData.themeMode) {
      localStorage.setItem('themeMode', essentialData.themeMode);
    }
    
    console.log('Cache and storage cleanup completed successfully');
    
    // 6. Notify all clients about the cleanup
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'CLEANUP_COMPLETE',
        version: currentVersion
      });
    });
  } catch (error) {
    console.error('Error during cleanup:', error);
  }
}

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year.
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache API responses
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.startsWith('/api/'),
  new StaleWhileRevalidate({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Enhanced push notification event listener with better Android support
self.addEventListener('push', (event) => {
  try {
    // Default notification data (fallback)
    let data = {
      title: 'New Notification',
      message: 'You have a new notification',
      url: '/app/notifications',  // Direct to notifications page by default
      timestamp: Date.now(),
      id: 'notification-' + Date.now()
    };
    
    // Parse notification data with robust error handling
    if (event.data) {
      try {
        // Try to parse as JSON first
        data = event.data.json();
        console.log('Successfully parsed push notification data');
      } catch (jsonError) {
        console.warn('Could not parse notification as JSON, trying as text:', jsonError);
        
        // Fallback to text parsing
        try {
          const text = event.data.text();
          if (text) {
            // If it's just text, use it as the message
            data.message = text;
            // Try to parse as JSON in case the text is actually JSON
            try {
              const parsedText = JSON.parse(text);
              data = { ...data, ...parsedText };
              console.log('Successfully parsed notification from text as JSON');
            } catch (e) {
              // Not JSON, just use as plain text
              console.log('Using notification as plain text');
            }
          }
        } catch (textError) {
          console.error('Failed to extract notification data:', textError);
        }
      }
    }
  
    // Create notification options with Android optimizations
    const options = {
      body: data.message || 'You have a new notification',
      
      // Icons - critical for Android display
      icon: '/logo192.png',  // Main notification icon
      badge: '/badge-icon.png',  // Android badge icon
      
      // Data to pass to the click handler
      data: {
        url: data.url || '/app/notifications',
        senderId: data.senderId || '',
        notificationId: data.id || ('notification-' + Date.now()),
        timestamp: data.timestamp || Date.now()
      },
      
      // Vibration pattern [vibrate, pause, vibrate] - works well on Android
      vibrate: [200, 100, 200],
      
      // Timestamp helps with notification ordering
      timestamp: data.timestamp || Date.now(),
      
      // Action buttons (Android shows these, iOS often doesn't)
      actions: [
        {
          action: 'view',
          title: 'View'
        },
        {
          action: 'dismiss',
          title: 'Dismiss'
        }
      ],
      
      // Android-specific enhancements
      tag: data.id || 'grade-tracker-notification',  // Group similar notifications
      renotify: true,  // Notify even when using the same tag
      silent: false,  // Ensure sound plays
      requireInteraction: true,  // Prevent auto-dismiss on Android
    };

    // Log notification attempt for debugging
    console.log('Showing notification:', data.title);
    
    // Show the notification with waitUntil to keep service worker alive
    return event.waitUntil(
      self.registration.showNotification(data.title, options)
        .then(() => {
          console.log('Notification displayed successfully');
          // You could add analytics tracking here
        })
        .catch(err => {
          console.error('Failed to display notification:', err);
          throw err; // Re-throw to trigger the catch below
        })
    );
  } catch (error) {
    console.error('Critical error handling push notification:', error);
    
    // Last resort fallback notification
    return event.waitUntil(
      self.registration.showNotification('New Message', {
        body: 'You have a new notification. Please open the app.',
        icon: '/logo192.png',
        data: { url: '/app/notifications' }
      })
    );
  }
});

self.addEventListener('notificationclick', (event) => {
  // Close the notification
  event.notification.close();
  
  // Handle the click action
  const action = event.action || 'default'; // 'default' means the notification body was clicked
  console.log('Notification click action:', action);
  
  // Dismiss is an explicit action - simply close the notification with no navigation
  if (action === 'dismiss') {
    return;
  }
  
  // Determine target URL - ensure notification.data exists and has a url
  let targetUrl = '/app/notifications'; // Safe default
  
  if (event.notification.data) {
    if (typeof event.notification.data.url === 'string' && event.notification.data.url) {
      targetUrl = event.notification.data.url;
    }
    
    // Ensure the URL starts with a slash for proper routing
    if (targetUrl && !targetUrl.startsWith('/')) {
      targetUrl = '/' + targetUrl;
    }
    
    // If the URL doesn't have the /app prefix but should, add it
    if (!targetUrl.startsWith('/app/') && !targetUrl.startsWith('/static/') && targetUrl !== '/') {
      // Preserve any hash or query parameters
      const urlParts = targetUrl.split(/[?#]/);
      const path = urlParts[0];
      const rest = targetUrl.substring(path.length);
      
      targetUrl = '/app' + path + rest;
    }
  }
  
  console.log('Will navigate to:', targetUrl);
  
  // Handle the notification click with more robust error handling
  event.waitUntil(
    (async () => {
      try {
        // Get all window clients
        const allClients = await self.clients.matchAll({
          type: 'window',
          includeUncontrolled: true
        });
        
        console.log('Found', allClients.length, 'open windows');
        
        // First try to find a client that's already open to the target URL
        let targetClient = allClients.find(client => {
          return client.url.includes(targetUrl);
        });
        
        // If exact match not found, look for any client on our origin
        if (!targetClient) {
          targetClient = allClients.find(client => {
            return client.url.includes(self.location.origin);
          });
        }
        
        // If we found an existing window
        if (targetClient) {
          console.log('Using existing window');
          
          // Focus the client
          await targetClient.focus();
          
          // Post a message to navigate to the correct URL if needed
          targetClient.postMessage({
            type: 'NOTIFICATION_NAVIGATION',
            url: targetUrl,
            notificationId: event.notification.data?.notificationId,
            timestamp: Date.now()
          });
          
          return;
        }
        
        // If no existing window, open a new one
        console.log('Opening new window to', targetUrl);
        
        // Android needs a fully qualified URL
        const fullUrl = new URL(targetUrl, self.location.origin).href;
        
        const newClient = await self.clients.openWindow(fullUrl);
        
        if (newClient) {
          console.log('New window opened successfully');
        } else {
          console.warn('Failed to open new window');
          // Try again with a direct open as fallback
          return self.clients.openWindow(fullUrl);
        }
      } catch (error) {
        console.error('Error handling notification click:', error);
        
        // Last resort fallback - open a window to our origin
        try {
          return self.clients.openWindow(self.location.origin + '/app/notifications');
        } catch (finalError) {
          console.error('Critical failure opening window:', finalError);
        }
      }
    })()
  );
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  // Handle update check message from the client
  if (event.data && event.data.type === 'CHECK_UPDATE') {
    console.log(`Service worker (version ${APP_VERSION}) received update check request`);
    self.registration.update();
  }
});
